//! Markdown Report Generator
//!
//! Generates markdown-formatted compliance reports suitable for:
//! - GitHub/GitLab PR comments
//! - README badges and summaries
//! - Documentation embedding

use super::timestamp;
use crate::compliance::{ComplianceResult, ViolationSeverity};

/// Markdown report generator
pub struct MarkdownGenerator;

impl MarkdownGenerator {
    /// Generate a complete markdown report
    #[allow(dead_code)]
    pub fn generate(result: &ComplianceResult, rules: Vec<(&str, &str)>) -> String {
        let mut md = String::new();

        // Header
        md.push_str("# UTF8DOK Compliance Report\n\n");

        // Summary badge
        let status_emoji = if result.errors > 0 {
            "‚ùå"
        } else if result.warnings > 0 {
            "‚ö†Ô∏è"
        } else {
            "‚úÖ"
        };

        let status_text = if result.errors > 0 {
            "FAILING"
        } else if result.warnings > 0 {
            "PASSING (with warnings)"
        } else {
            "PASSING"
        };

        md.push_str(&format!("**Status:** {} {}\n\n", status_emoji, status_text));

        // Stats table
        md.push_str("## Summary\n\n");
        md.push_str("| Metric | Value |\n");
        md.push_str("|--------|-------|\n");
        md.push_str(&format!("| Documents | {} |\n", result.total_documents));
        md.push_str(&format!("| Errors | {} |\n", result.errors));
        md.push_str(&format!("| Warnings | {} |\n", result.warnings));
        md.push_str(&format!("| Info | {} |\n", result.info));
        md.push_str(&format!("| Compliance Score | {}% |\n", result.compliance_score));
        md.push('\n');

        // Violations section
        if result.violations.is_empty() {
            md.push_str("## Violations\n\n");
            md.push_str("üéâ **All compliance checks passed!**\n\n");
        } else {
            md.push_str("## Violations\n\n");

            for violation in &result.violations {
                let emoji = match violation.severity {
                    ViolationSeverity::Error => "‚ùå",
                    ViolationSeverity::Warning => "‚ö†Ô∏è",
                    ViolationSeverity::Info => "‚ÑπÔ∏è",
                };

                let severity = match violation.severity {
                    ViolationSeverity::Error => "ERROR",
                    ViolationSeverity::Warning => "WARNING",
                    ViolationSeverity::Info => "INFO",
                };

                // Extract filename from URI
                let filename = violation
                    .uri
                    .path_segments()
                    .and_then(|mut segments| segments.next_back())
                    .unwrap_or("unknown");

                md.push_str(&format!(
                    "### {} `{}` - {}\n\n",
                    emoji, violation.code, severity
                ));
                md.push_str(&format!("{}\n\n", violation.message));
                md.push_str(&format!(
                    "üìç `{}:{}:{}`\n\n",
                    filename,
                    violation.range.start.line + 1,
                    violation.range.start.character + 1
                ));
            }
        }

        // Rules section
        if !rules.is_empty() {
            md.push_str("## Active Rules\n\n");
            md.push_str("| Code | Description |\n");
            md.push_str("|------|-------------|\n");
            for (code, description) in rules {
                md.push_str(&format!("| `{}` | {} |\n", code, description));
            }
            md.push('\n');
        }

        // Footer
        md.push_str("---\n\n");
        md.push_str(&format!(
            "_Generated by [UTF8DOK Compliance Engine](https://github.com/utf8dok/utf8dok) at {}_\n",
            timestamp()
        ));

        md
    }

    /// Generate a compact summary for PR comments
    #[allow(dead_code)]
    pub fn generate_compact(result: &ComplianceResult) -> String {
        let mut md = String::new();

        let status = if result.errors > 0 {
            "‚ùå **Compliance: FAILING**"
        } else if result.warnings > 0 {
            "‚ö†Ô∏è **Compliance: PASSING (with warnings)**"
        } else {
            "‚úÖ **Compliance: PASSING**"
        };

        md.push_str(status);
        md.push_str(&format!(
            " | Score: {}% | {} docs | {} errors | {} warnings\n",
            result.compliance_score, result.total_documents, result.errors, result.warnings
        ));

        if !result.violations.is_empty() {
            md.push_str("\n<details>\n<summary>View violations</summary>\n\n");

            for violation in &result.violations {
                let emoji = match violation.severity {
                    ViolationSeverity::Error => "‚ùå",
                    ViolationSeverity::Warning => "‚ö†Ô∏è",
                    ViolationSeverity::Info => "‚ÑπÔ∏è",
                };

                let filename = violation
                    .uri
                    .path_segments()
                    .and_then(|mut segments| segments.next_back())
                    .unwrap_or("unknown");

                md.push_str(&format!(
                    "- {} **{}**: {} (`{}`)\n",
                    emoji, violation.code, violation.message, filename
                ));
            }

            md.push_str("\n</details>\n");
        }

        md
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compliance::Violation;
    use tower_lsp::lsp_types::{Position, Range, Url};

    #[test]
    fn test_generate_clean_report() {
        let result = ComplianceResult {
            violations: vec![],
            errors: 0,
            warnings: 0,
            info: 0,
            total_documents: 5,
            compliance_score: 100,
        };

        let md = MarkdownGenerator::generate(&result, vec![]);
        assert!(md.contains("‚úÖ PASSING"));
        assert!(md.contains("All compliance checks passed!"));
        assert!(md.contains("100%"));
    }

    #[test]
    fn test_generate_with_violations() {
        let result = ComplianceResult {
            violations: vec![Violation {
                uri: Url::parse("file:///test.adoc").unwrap(),
                range: Range {
                    start: Position {
                        line: 0,
                        character: 0,
                    },
                    end: Position {
                        line: 0,
                        character: 0,
                    },
                },
                message: "Test violation".to_string(),
                severity: ViolationSeverity::Error,
                code: "TEST001".to_string(),
            }],
            errors: 1,
            warnings: 0,
            info: 0,
            total_documents: 5,
            compliance_score: 80,
        };

        let md = MarkdownGenerator::generate(&result, vec![("TEST001", "Test rule")]);
        assert!(md.contains("‚ùå FAILING"));
        assert!(md.contains("TEST001"));
        assert!(md.contains("Test violation"));
        assert!(md.contains("Test rule"));
    }

    #[test]
    fn test_generate_compact() {
        let result = ComplianceResult {
            violations: vec![Violation {
                uri: Url::parse("file:///test.adoc").unwrap(),
                range: Range {
                    start: Position {
                        line: 0,
                        character: 0,
                    },
                    end: Position {
                        line: 0,
                        character: 0,
                    },
                },
                message: "Test issue".to_string(),
                severity: ViolationSeverity::Warning,
                code: "TEST002".to_string(),
            }],
            errors: 0,
            warnings: 1,
            info: 0,
            total_documents: 3,
            compliance_score: 90,
        };

        let compact = MarkdownGenerator::generate_compact(&result);
        assert!(compact.contains("‚ö†Ô∏è"));
        assert!(compact.contains("<details>"));
        assert!(compact.contains("TEST002"));
    }
}
